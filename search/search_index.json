{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"backend/exception/","text":"Exception handling Various errors can occur in the backend, which must be made understandable to the end user and the developers when calling the API. In general, please use the following syntax to return a error message from the backend: routes.py from fastapi import HTTPException raise HTTPException ( status_code = 403 , # (1) detail = { \"err_code\" : \"project_deletion_permission_denied\" , # (2) \"title\" : \"Permission denied\" , # (3) \"reason\" : ( \"You don't have the permission to delete projects.\" , \"Please ask your administrator to delete the project.\" , ), # (4) \"technical\" : \"The role administrator is required.\" , # (5) }, ) Please use the corresponding HTTP response status code here. More information about status codes: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status Optional : Unique error code (as string). Can be evaluated in the frontend to identify a specific error. Optional : Use a title that is automatically displayed in the frontend (only works when the reason parameter is provided). Optional : Use a message that is automatically displayed in the frontend for users. Since the message will be displayed to end users, it should contain context for classification and should be user-friendly (not technical!) Optional : Technical message for developers, not displayed in the frontend. Is part of the error response json.","title":"Exception handling"},{"location":"backend/exception/#exception-handling","text":"Various errors can occur in the backend, which must be made understandable to the end user and the developers when calling the API. In general, please use the following syntax to return a error message from the backend: routes.py from fastapi import HTTPException raise HTTPException ( status_code = 403 , # (1) detail = { \"err_code\" : \"project_deletion_permission_denied\" , # (2) \"title\" : \"Permission denied\" , # (3) \"reason\" : ( \"You don't have the permission to delete projects.\" , \"Please ask your administrator to delete the project.\" , ), # (4) \"technical\" : \"The role administrator is required.\" , # (5) }, ) Please use the corresponding HTTP response status code here. More information about status codes: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status Optional : Unique error code (as string). Can be evaluated in the frontend to identify a specific error. Optional : Use a title that is automatically displayed in the frontend (only works when the reason parameter is provided). Optional : Use a message that is automatically displayed in the frontend for users. Since the message will be displayed to end users, it should contain context for classification and should be user-friendly (not technical!) Optional : Technical message for developers, not displayed in the frontend. Is part of the error response json.","title":"Exception handling"},{"location":"backend/extensions/","text":"In order to make the whole backend more consistent, it is divided into different modules. This is intended to ensure that these are outsourced easily and without major effects and that other modules can also be easily added as \"plugins\", e.g., via Python entrypoints . A extension has the following structure: extension \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 crud.py \u251c\u2500\u2500 models.py \u251c\u2500\u2500 routes.py \u2514\u2500\u2500 ... The different components are explained in the following section. Extension modules __init__.py Code to be called to initialize a module. crud.py All CRUD (Create, read, update and delete) related operations. They should be used to access the database. There should not be much logic in the crud.py files (really just creating, reading, updating and deleting) models in the database. models.py In the models module, all pydantic and SQLAlchemy models should be defined. In general, we use the Database prefix for SQLAlchemy models, e.g., DatabaseProject . routes.py The routes module should include all fastAPI routes. ... Other submodules can of course be created and are usually also useful if logic needs to be implemented. Entrypoints Core modules are directly imported in the code. However, for modules that change frequently or should be interchangeable, we use Python entrypoints. A entrypoint can be defined in the pyproject.toml file: pyproject.toml [ project . entry - points . \"capellacollab.extensions\" ] extension1 = \"path.to.extension1\" extension2 = \"path.to.extension2\" The routes and models components are then imported in the code: For example, to include the routers, we use the following code: routes.py eps = metadata . entry_points ()[ \"capellacollab.extensions\" ] for ep in eps : log . info ( \"Add routes of extension %s \" , ep . name ) router . include_router ( importlib . import_module ( \".routes\" , ep . module ) . router , prefix = \"/ {project} /extensions/\" + ep . name , tags = [ ep . name ], )","title":"Extension modules"},{"location":"backend/extensions/#extension-modules","text":"","title":"Extension modules"},{"location":"backend/extensions/#__init__py","text":"Code to be called to initialize a module.","title":"__init__.py"},{"location":"backend/extensions/#crudpy","text":"All CRUD (Create, read, update and delete) related operations. They should be used to access the database. There should not be much logic in the crud.py files (really just creating, reading, updating and deleting) models in the database.","title":"crud.py"},{"location":"backend/extensions/#modelspy","text":"In the models module, all pydantic and SQLAlchemy models should be defined. In general, we use the Database prefix for SQLAlchemy models, e.g., DatabaseProject .","title":"models.py"},{"location":"backend/extensions/#routespy","text":"The routes module should include all fastAPI routes.","title":"routes.py"},{"location":"backend/extensions/#_1","text":"Other submodules can of course be created and are usually also useful if logic needs to be implemented.","title":"..."},{"location":"backend/extensions/#entrypoints","text":"Core modules are directly imported in the code. However, for modules that change frequently or should be interchangeable, we use Python entrypoints. A entrypoint can be defined in the pyproject.toml file: pyproject.toml [ project . entry - points . \"capellacollab.extensions\" ] extension1 = \"path.to.extension1\" extension2 = \"path.to.extension2\" The routes and models components are then imported in the code: For example, to include the routers, we use the following code: routes.py eps = metadata . entry_points ()[ \"capellacollab.extensions\" ] for ep in eps : log . info ( \"Add routes of extension %s \" , ep . name ) router . include_router ( importlib . import_module ( \".routes\" , ep . module ) . router , prefix = \"/ {project} /extensions/\" + ep . name , tags = [ ep . name ], )","title":"Entrypoints"},{"location":"backend/technology/","text":"We use some different libraries in the backend. Here is a quick overview. FastAPI FastAPI is used to serve the backend API endpoints. SQLAlchemy We use SQLAlchemy as ORM for our PostgreSQL database. Alembic Alembic is used for database migrations.","title":"Technology overview"},{"location":"backend/technology/#fastapi","text":"FastAPI is used to serve the backend API endpoints.","title":"FastAPI"},{"location":"backend/technology/#sqlalchemy","text":"We use SQLAlchemy as ORM for our PostgreSQL database.","title":"SQLAlchemy"},{"location":"backend/technology/#alembic","text":"Alembic is used for database migrations.","title":"Alembic"},{"location":"frontend/routes/","text":"Frontend routes For consistency, we have a strict structure for our frontend route URIs. The structure is based on REST, but not completely the same due to the limitations of the unavailable request methods. /resources for the resource overview, e.g., /projects for the projects overview /resources/action for a specific action (not related to a specific instance of the resource), e.g., /projects/create to create a project. Possible actions are: create delete or any other action if the action is not used to create or delete a resource. /resources/action/subaction for a specific action related to a parent action, e.g., /project/:name/models/create/source to go to the source stage of the model creation. resource/:name to access a single instance of type resource. resource/:name/childresource to access a single child resource of a specific instance from type resource. Examples Valid routes are: /project/test/models/create is a valid route to create a model in the project test . /projects is a valid route for the overview of projects. These are not valid: /project/create ( project should be plural) /models ( models is a child resource of projects , therefore it should be /projects/:id/models )","title":"Routes"},{"location":"frontend/routes/#frontend-routes","text":"For consistency, we have a strict structure for our frontend route URIs. The structure is based on REST, but not completely the same due to the limitations of the unavailable request methods. /resources for the resource overview, e.g., /projects for the projects overview /resources/action for a specific action (not related to a specific instance of the resource), e.g., /projects/create to create a project. Possible actions are: create delete or any other action if the action is not used to create or delete a resource. /resources/action/subaction for a specific action related to a parent action, e.g., /project/:name/models/create/source to go to the source stage of the model creation. resource/:name to access a single instance of type resource. resource/:name/childresource to access a single child resource of a specific instance from type resource.","title":"Frontend routes"},{"location":"frontend/routes/#examples","text":"Valid routes are: /project/test/models/create is a valid route to create a model in the project test . /projects is a valid route for the overview of projects. These are not valid: /project/create ( project should be plural) /models ( models is a child resource of projects , therefore it should be /projects/:id/models )","title":"Examples"},{"location":"frontend/testing/","text":"Frontend Testing Unit & Integration testing Technologies We use Jasmine as testing framework Karma is used as test runner We use istanbul to measure and visualize the code coverage Additional sources Official angular testing guide Recommended: Detailed angular testing guide General Robust component tests When testing components, we must query the elements needed for the test. To ensure that even if the element type or attributes changes, the element can still be queried, we assign a data-testId to each needed element. This not only increases robustness, but also makes it very easy to query elements. The value assigned to the test id should clearly describe the usage of the element and should not be too long. For example, one can use the schema data-testId=<type>-<description> where the prefix usually describes the general contex (e.g., whether it is an input, button, textfield, etc.) and the following description specifies the usage of it (e.g., createProject). Element helper functions Usually testing components consists of querying elements, applying changes to them, triggering events on them, and then comparing the results with the expected results. To reduce repetition and increase readability, one should use existing helper functions or create new ones if none exist. Executing tests To execute the integration tests, one needs to run make test . However, in some cases it is not possible to correctly set the CHROME_BIN that is needed to generate the test output inside the browser. If this is the case, one should either set the CHORME_BIN in the make file or simply run EXPORT CHROME_BIN=<path> followed by ng test . Beyond that, it is not necessary to run anything else (e.g., the backend) for test execution. Output The resulting output in the browser considers three different cases: Green tests are successful tests Yellow tests (marked with a \u2606) are deactivated tests Red tests are failed tests The general code coverage statistics (i.e. statement, branch, function, and line coverage) are output to the console. To also see what exactly is covered and what is missing, one can open the index.html file in the /frontend/test-results/istanbul-coverage folder. End-to-End testing Technologies We use playwright for E2E testing Test generation Playwright supports the generation of E2E tests by interacting with the frontend and recording each action and input. This can be started by executing npx playwright codegen localhost:4200 but needs a running frontend and backend to work. Test generation can significantly speed up test creation, but in general one should only use the resulting test as a base and adjust it accordingly. For example, check selectors and adjust them to make them more robust, or add more expectations as needed. Executing tests To run the E2E tests, one must first make sure that a backend is running. If that is the case, one can run npx playwright test to start the tests. In case of an error the browser will be directly opened and show the last test report, otherwise one can open it with npx playwright show-report . A very helpful option when running the tests is --trace on . This provides, for example, a screenshot of the action and the before/after state (for each step), contains a detailed log, and one can also view the console output and network calls performed.","title":"Testing"},{"location":"frontend/testing/#frontend-testing","text":"","title":"Frontend Testing"},{"location":"frontend/testing/#unit-integration-testing","text":"","title":"Unit &amp; Integration testing"},{"location":"frontend/testing/#technologies","text":"We use Jasmine as testing framework Karma is used as test runner We use istanbul to measure and visualize the code coverage","title":"Technologies"},{"location":"frontend/testing/#additional-sources","text":"Official angular testing guide Recommended: Detailed angular testing guide","title":"Additional sources"},{"location":"frontend/testing/#general","text":"","title":"General"},{"location":"frontend/testing/#robust-component-tests","text":"When testing components, we must query the elements needed for the test. To ensure that even if the element type or attributes changes, the element can still be queried, we assign a data-testId to each needed element. This not only increases robustness, but also makes it very easy to query elements. The value assigned to the test id should clearly describe the usage of the element and should not be too long. For example, one can use the schema data-testId=<type>-<description> where the prefix usually describes the general contex (e.g., whether it is an input, button, textfield, etc.) and the following description specifies the usage of it (e.g., createProject).","title":"Robust component tests"},{"location":"frontend/testing/#element-helper-functions","text":"Usually testing components consists of querying elements, applying changes to them, triggering events on them, and then comparing the results with the expected results. To reduce repetition and increase readability, one should use existing helper functions or create new ones if none exist.","title":"Element helper functions"},{"location":"frontend/testing/#executing-tests","text":"To execute the integration tests, one needs to run make test . However, in some cases it is not possible to correctly set the CHROME_BIN that is needed to generate the test output inside the browser. If this is the case, one should either set the CHORME_BIN in the make file or simply run EXPORT CHROME_BIN=<path> followed by ng test . Beyond that, it is not necessary to run anything else (e.g., the backend) for test execution.","title":"Executing tests"},{"location":"frontend/testing/#output","text":"The resulting output in the browser considers three different cases: Green tests are successful tests Yellow tests (marked with a \u2606) are deactivated tests Red tests are failed tests The general code coverage statistics (i.e. statement, branch, function, and line coverage) are output to the console. To also see what exactly is covered and what is missing, one can open the index.html file in the /frontend/test-results/istanbul-coverage folder.","title":"Output"},{"location":"frontend/testing/#end-to-end-testing","text":"","title":"End-to-End testing"},{"location":"frontend/testing/#technologies_1","text":"We use playwright for E2E testing","title":"Technologies"},{"location":"frontend/testing/#test-generation","text":"Playwright supports the generation of E2E tests by interacting with the frontend and recording each action and input. This can be started by executing npx playwright codegen localhost:4200 but needs a running frontend and backend to work. Test generation can significantly speed up test creation, but in general one should only use the resulting test as a base and adjust it accordingly. For example, check selectors and adjust them to make them more robust, or add more expectations as needed.","title":"Test generation"},{"location":"frontend/testing/#executing-tests_1","text":"To run the E2E tests, one must first make sure that a backend is running. If that is the case, one can run npx playwright test to start the tests. In case of an error the browser will be directly opened and show the last test report, otherwise one can open it with npx playwright show-report . A very helpful option when running the tests is --trace on . This provides, for example, a screenshot of the action and the before/after state (for each step), contains a detailed log, and one can also view the console output and network calls performed.","title":"Executing tests"}]}